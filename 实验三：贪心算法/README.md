# 实验一：分治算法实验报告

## 学号：20201060564

## 实验目的：

编程实现经典的贪心算法，理解贪心算法设计的基本思想、程序实现的相关技巧，加深对贪心算法设计与分析思想的理解。通过程序的执行时间测试结果，与理论上的时间复杂度结论进行对比、分析和验证。

## 实验原理

编程实现以上求解背包问题的贪心算法，并通过手动设置、生成随机数获得实验数据。记录随着输入规模增加算法的执行时间，分析并以图形方式展现增长率；测试、验证、对比算法的时间复杂度。


## 实验输入数据集

键盘输入：背包的容量、背包内物品的个数
自动生成：物品的重量、物品的价值

## 实验内容
(1) 编程实现以上 KnapsackGreedy 算法，并进行测试，保证程序正确无误。其中，分别在程序开始和结束处设置记录系统当前时间的变量、用于计算程序执行的时间（以毫秒(ms)作为时间的计数单位）。
(2) 设定一个 m 值，测试随着 n 增加、程序执行时间增加的趋势。分别使用1.1 节中的随机数生成算法生成 n 个随机数作为 n 个物品的重量，再生成 n 个随机数作为 n 个物品的价值（n=10, 20, 40, 100, 200, 400, 800, 2000）。记录随着 n增加程序的执行时间，并使用 MS Excel、Matlab 或 Origin 等图表绘制工具生成程序执行时间的对比曲线图。
(3) 与理论上的时间复杂度结论进行对比分析，完成实验报告。

## 实验预期结果与实际结果
（2）n个物品（n=10, 20, 40, 100, 200, 400, 800, 2000），m设定为500
![image](https://github.com/wtiantianw/homewrok_template/blob/main/%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/%E6%B5%8B%E9%AA%8C100.png)
![image](https://github.com/wtiantianw/homewrok_template/blob/main/%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/%E6%B5%8B%E9%AA%8C100%EF%BC%882%EF%BC%89.png)

对比两次随机生成数据的比较次数发现，两次的比较次数相差微乎其微，得出输入数据等价类的含义：就是把所有可能的输入数据，即程序的输入域划分成若干部分（子集），然后从每一个子集中选取少数具有代表性的数据作为测试用例。
（3）![image](https://github.com/wtiantianw/homewrok_template/blob/main/%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/%E4%B8%8D%E5%90%8C%E8%A7%84%E6%A8%A1%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8A%98%E7%BA%BF%E5%9B%BE.png)
  通过生成不同规模的测试数据，我的结论如下：冒泡排序比较次数最多，归并排序次之，快速排序最少。
  渐进时间复杂度反映的是随着问题规模的变大，计算所需的时间的增长速度，与系数的多少关系不大。
  常见的时间复杂度及其增长速度比较为：
O(1)＜O(log n)＜O(n)＜O(nlog n)＜O(n^2)＜O(n^3)< O(2^n)＜O(n!)＜O(n^n)
根据折线图可以看出，归并排序和快速排序近乎在一条直线上，说明这两种算法归为一类复杂度，就是O（nlogn），而冒泡算法则归结为O（n^2）





```bash
gitpod /workspace/homewrok_template (main) $ gcc -o max.exe max.c
gitpod /workspace/homewrok_template (main) $ ./max.exe 
```



