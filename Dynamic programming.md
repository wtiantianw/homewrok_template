# 实验二：动态规划算法

## 学号：20201060564

## 实验目的：

编程实现经典的动态规划算法，理解动态规划算法设计的基本思想、程序实现的相关技巧，加深对动态规划算法设计与分析思想的理解。通过程序的执行时间测试结果，与理论上的时间复杂度结论进行对比、分析和验证。

## 实验原理

动态规划是一种在数学和计算机科学中使用的、用于求解包含重叠子问题的最优化问题的有效方法。其基本思想是：将原问题分解为相似的子问题，在求解的过程中通过子问题的解描述并求出原问题的解。动态规划的思想是多种算法的基础，被广泛应用于计算机科学和工程领域，在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题，为了避免多次解决这些子问题，它们的结果都逐渐被计算并保存，从小规模的子问题直到整个问题都被解决。因此，动态规划对每一子问题只做一次计算，具有较高的效率。

## 实验输入数据集

键盘输入：背包的容量、背包内物品的个数
自动生成：物品的重量、物品的价值

## 实验内容
(1) 编程实现以上算法，并进行测试，保证程序正确无误。其中，分别在程序开始和结束处设置记录系统当前时间的变量、用于计算程序执行的时间（以毫秒(ms)作为程序执行时间的计数单位）。
(2) 测试 C 值不变的情形下随着 n 增加、程序执行时间增加的趋势。对于C=200、400、800、2000 这四种情形，分别使用 1.1 节中的随机数生成算法生成n 个随机数作为 n 个物品的重量，再生成 n 个随机数作为 n 个物品的价值（n=10,20, 40, 100, 200, 400, 800, 2000）。对于每个 C 值，记录随着 n 增加程序的执行时间，并使用 MS Excel、Matlab 或 Origin 等图表绘制工具生成各不同 C 值情形下程序执行时间的对比曲线图（4 条折线）。
(3) 与理论上的时间复杂度结论进行对比分析，完成实验报告。

## 实验预期结果与实际结果
算法空间复杂度与时间复杂度均为O(n*m)。其中m为背包容量
实验过程及实验结果（C版）
（1）因为运行结果图较多，所以在这里展示随机生成100个数的运行结果：
![image](https://github.com/wtiantianw/homewrok_template/blob/main/DP-100.png)
（2）![image](https://github.com/wtiantianw/homewrok_template/blob/main/%E4%B8%8D%E5%90%8C%E8%A7%84%E6%A8%A1%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8A%98%E7%BA%BF%E5%9B%BE.png)

  通过生成不同规模的测试数据，我的结论如下：冒泡排序比较次数最多，归并排序次之，快速排序最少。
  渐进时间复杂度反映的是随着问题规模的变大，计算所需的时间的增长速度，与系数的多少关系不大。
  常见的时间复杂度及其增长速度比较为：
O(1)＜O(log n)＜O(n)＜O(nlog n)＜O(n^2)＜O(n^3)< O(2^n)＜O(n!)＜O(n^n)
根据折线图可以看出，归并排序和快速排序近乎在一条直线上，说明这两种算法归为一类复杂度，就是O（nlogn），而冒泡算法则归结为O（n^2）





```bash
gitpod /workspace/homewrok_template (main) $ gcc -o max.exe max.c
gitpod /workspace/homewrok_template (main) $ ./max.exe 
```


