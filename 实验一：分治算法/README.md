# 实验一：分治算法实验报告

## 学号：20201060564

## 实验目的：

通过排序算法的程序实现和执行时间测试，与理论上的结论进行对比分析，深入理解算法时间复杂度渐进性态和和增长率的概念；理解分治算法设计的基本思想、递归程序实现的基本方法，加深对分治算法设计与分析思想的理解。

## 实验原理

以冒泡排序、合并排序和快速排序算法为例，以生成的随机数作为实验中使用的测试数据。对每个算法，记录程序执行中随着测试数据增加算法基本操作执行次数，分析并以图形方式展现增长率；对以上三个排序算法，对比随着测试数
据增加算法增长率变化趋势；测试、验证、对比算法时间复杂度的理论结论。


## 实验输入数据集

使用线性同余法生成的随机数

## 实验内容
(1) “比较”是以上排序算法的基本操作（即决定算法执行效率的主要操作），在算法中设置比较操作的计数器，编程实现算法（输出最终的计数值）并进行测
试，保证程序正确无误。
(2) 使用随机数生成方法生成包含 100 个随机数的测试数据，记录这些数据，并分别记录以上三个排序算法比较操作的执行次数；再重新生成包含 100 个随机数的测试数据，记录这些数据三个排序算法比较操作的执行次数。对比两次生成的测试数据和算法执行中比较操作的次数，理解算法复杂度分析时输入数据等价类的含义。
(3) 使用随机数生成方法生成不同规模的测试数据（10 个，100 个，1000 个，2000 个，5000 个，10000 个，100000 个，……），对于每种规模的测试数据，分别记录 BubbleSort、MergeSort 和 QuickSort 算法执行中比较操作的执行次数，使用 MS Excel、Matlab 或 Origin 等图表绘制工具生成随着输入数据增加、以上三个算法比较操作次数增加的对比曲线图（折线）。基于生成的曲线图，与时间复杂度的理论结论对比分析，理解计算时间渐进性态和增长率的概念。

## 实验预期结果与实际结果
+ 实验预期结果：冒泡排序最慢，快速排序和归并排序时间复杂度相同，但经过实验验证快速排序的比较次数更少
实验过程及实验结果（C版）
（2）随机生成100个数三种算法的比较：
![image](https://github.com/wtiantianw/homewrok_template/blob/main/%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/%E6%B5%8B%E9%AA%8C100.png)
![image](https://github.com/wtiantianw/homewrok_template/blob/main/%E6%B5%8B%E9%AA%8C100%EF%BC%882%EF%BC%89.png）

对比两次随机生成数据的比较次数发现，两次的比较次数相差微乎其微，得出输入数据等价类的含义：就是把所有可能的输入数据，即程序的输入域划分成若干部分（子集），然后从每一个子集中选取少数具有代表性的数据作为测试用例。
（3）![image](# 实验一：分治算法实验报告

## 学号：20201060564

## 实验目的：

通过排序算法的程序实现和执行时间测试，与理论上的结论进行对比分析，深入理解算法时间复杂度渐进性态和和增长率的概念；理解分治算法设计的基本思想、递归程序实现的基本方法，加深对分治算法设计与分析思想的理解。

## 实验原理

以冒泡排序、合并排序和快速排序算法为例，以生成的随机数作为实验中使用的测试数据。对每个算法，记录程序执行中随着测试数据增加算法基本操作执行次数，分析并以图形方式展现增长率；对以上三个排序算法，对比随着测试数
据增加算法增长率变化趋势；测试、验证、对比算法时间复杂度的理论结论。


## 实验输入数据集

使用线性同余法生成的随机数

## 实验内容
(1) “比较”是以上排序算法的基本操作（即决定算法执行效率的主要操作），在算法中设置比较操作的计数器，编程实现算法（输出最终的计数值）并进行测
试，保证程序正确无误。
(2) 使用随机数生成方法生成包含 100 个随机数的测试数据，记录这些数据，并分别记录以上三个排序算法比较操作的执行次数；再重新生成包含 100 个随机数的测试数据，记录这些数据三个排序算法比较操作的执行次数。对比两次生成的测试数据和算法执行中比较操作的次数，理解算法复杂度分析时输入数据等价类的含义。
(3) 使用随机数生成方法生成不同规模的测试数据（10 个，100 个，1000 个，2000 个，5000 个，10000 个，100000 个，……），对于每种规模的测试数据，分别记录 BubbleSort、MergeSort 和 QuickSort 算法执行中比较操作的执行次数，使用 MS Excel、Matlab 或 Origin 等图表绘制工具生成随着输入数据增加、以上三个算法比较操作次数增加的对比曲线图（折线）。基于生成的曲线图，与时间复杂度的理论结论对比分析，理解计算时间渐进性态和增长率的概念。

## 实验预期结果与实际结果
+ 实验预期结果：冒泡排序最慢，快速排序和归并排序时间复杂度相同，但经过实验验证快速排序的比较次数更少
实验过程及实验结果（C版）
（2）随机生成100个数三种算法的比较：
![image](https://github.com/wtiantianw/homewrok_template/blob/main/%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/%E6%B5%8B%E9%AA%8C100.png)
![image]([https://github.com/wtiantianw/homewrok_template/blob/main/%E6%B5%8B%E9%AA%8C100%EF%BC%882%EF%BC%89.png](https://github.com/wtiantianw/homewrok_template/blob/main/%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/%E6%B5%8B%E9%AA%8C100%EF%BC%882%EF%BC%89.png)

对比两次随机生成数据的比较次数发现，两次的比较次数相差微乎其微，得出输入数据等价类的含义：就是把所有可能的输入数据，即程序的输入域划分成若干部分（子集），然后从每一个子集中选取少数具有代表性的数据作为测试用例。
（3）![image](https://github.com/wtiantianw/homewrok_template/blob/main/%E4%B8%8D%E5%90%8C%E8%A7%84%E6%A8%A1%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8A%98%E7%BA%BF%E5%9B%BE.png）
  通过生成不同规模的测试数据，我的结论如下：冒泡排序比较次数最多，归并排序次之，快速排序最少。
  渐进时间复杂度反映的是随着问题规模的变大，计算所需的时间的增长速度，与系数的多少关系不大。
  常见的时间复杂度及其增长速度比较为：
O(1)＜O(log n)＜O(n)＜O(nlog n)＜O(n^2)＜O(n^3)< O(2^n)＜O(n!)＜O(n^n)
根据折线图可以看出，归并排序和快速排序近乎在一条直线上，说明这两种算法归为一类复杂度，就是O（nlogn），而冒泡算法则归结为O（n^2）





```bash
gitpod /workspace/homewrok_template (main) $ gcc -o max.exe max.c
gitpod /workspace/homewrok_template (main) $ ./max.exe 
```

)
  通过生成不同规模的测试数据，我的结论如下：冒泡排序比较次数最多，归并排序次之，快速排序最少。
  渐进时间复杂度反映的是随着问题规模的变大，计算所需的时间的增长速度，与系数的多少关系不大。
  常见的时间复杂度及其增长速度比较为：
O(1)＜O(log n)＜O(n)＜O(nlog n)＜O(n^2)＜O(n^3)< O(2^n)＜O(n!)＜O(n^n)
根据折线图可以看出，归并排序和快速排序近乎在一条直线上，说明这两种算法归为一类复杂度，就是O（nlogn），而冒泡算法则归结为O（n^2）





```bash
gitpod /workspace/homewrok_template (main) $ gcc -o max.exe max.c
gitpod /workspace/homewrok_template (main) $ ./max.exe 
```


